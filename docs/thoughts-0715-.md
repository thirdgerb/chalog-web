
检查一下我们现在需要用几种服务端推送方式:

1. 同步响应. socket.emit();
2. 房间广播. socket.room.emit(), 用于群聊模式.
3. 会话通知, 只给予会话的提示. 应该是向管理员房间广播. io.room(admin).emit
4. 多人私聊. 两人以上本质上都是群. 要能够正确建立房间.

房间的性质:

1. 机器人为主: 所有人的消息广播给其它人, 都发送给机器人.
2. 人 vs 机器人+管理员: 人与机器人对话, 管理员发的消息不给机器人, 或者是 delivery.
3. 群聊房间: 人与人相互说法, @bot 的消息会提交给机器人.

房间的性质还要允许变更. 变更房间性质后, 处理的逻辑就截然不同了.
初期可以不要做太复杂. 用一个极简的方式.

简化后的房间性质:

1. 群聊. 只有 @bot 的消息才会发送给机器人.
2. 机器人聊. 只有 用户本人的消息才会发送给机器人.

管理员根据登录的情况, 会有一个独立的群.


* 通信架构

----

使用 Socket.io 实现网页版双工客户端. 需要把 Commune 的策略和 Socket.io 的一致化.

Socket IO 概念:
- namespace
- room
- event

Commune 概念:
- creatorId
- scene
- sessionId

现在考虑 SessionId == Room. 这样可以往相同 SessionId 的所有连接发送消息.
实现客户端级别的广播.

Event 对与服务端和客户端, 都意味着不同的处理逻辑.

namespace 暂时考虑不用.

身份校验问题? 需要一个 JWT 来定义用户的身份. 所以每一帧的消息都要校验?

* 通信架构.
